---
title: 深入理解Java虚拟机--读书笔记
date: 2018-01-29 21:57:24
type: "tags"
tags: [jvm]
---

> 最近认识到自己的薄弱点，需要狠狠补一下！

<!--more-->

花似雾中看，拨云见南山。
鲲鹏九万里，一览众山小。

### Part 1

> 第一部分，**走进java**，讲述了jvm的发展史，这里就不多做赘述了。贴上作者在infoq的文章~
[Java虚拟机家族考](http://www.infoq.com/cn/articles/jvm-family)


### Part 2 

> 第二部分，**自动内存管理机制**

#### 运行时数据区域

![Java虚拟机运行时数据区](http://oqipguzbl.bkt.clouddn.com/jvm-java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png)

##### Program Counter Register（程序计数器）

* 较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变计数器的值来选择下一条的指令，分支、循环、跳转、异常处理、线程恢复也依赖计数器。
* 每条线程独立拥有，且互不影响，独立存储（线程私有）
* 如果线程正在执行Java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是native方法，则这个计数器则为空。且是jvm中唯一没有规定OOM的区域。

这里对于计数器为何为空，转自[R大的回答](https://www.zhihu.com/question/40598119/answer/87381512)

这里的“pc寄存器”是在抽象的JVM层面上的概念——当执行Java方法时，这个抽象的“pc寄存器”存的是Java字节码的地址。实现上可能有两种形式，一种是相对该方法字节码开始处的偏移量，叫做bytecode index，简称bci；另一种是该Java字节码指令在内存里的地址，叫做bytecode pointer，简称bcp。

对native方法而言，它的方法体并不是由Java字节码构成的，自然无法应用上述的“Java字节码地址”的概念。所以JVM规范规定，如果当前执行的方法是native的，那么pc寄存器的值未定义——是什么值都可以。

上面是JVM规范所定义的抽象概念，那么实际实现呢？

Java线程总是需要以某种形式映射到OS线程上。映射模型可以是1:1（原生线程模型）、n:1（绿色线程/用户态线程模型）、m:n（混合模型）。

以HotSpot VM的实现为例，它目前在大多数平台上都使用1:1模型，也就是每个Java线程都直接映射到一个OS线程上执行。此时，native方法就由原生平台直接执行，并不需要理会抽象的JVM层面上的“pc寄存器”概念——原生的CPU上真正的PC寄存器是怎样就是怎样。就像一个用C或C++写的多线程程序，它在线程切换的时候是怎样的，Java的native方法也就是怎样的。

##### Java Virtual Machine Stacks（Java 虚拟机栈）

* 同样为线程私有
* 每个方法被执行的时候都会同时创建一个栈帧 （Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。
* 这里的局部变量表存放了各种基本类型（比如int、float等）**其中64位的long和double类型占用2个局部变量空间（Slot）**,其他占用为1个，对象引用和returnA	ddress类型（指向一条字节码指定的地址）
* 其中如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。以及在动态扩展内存的时候无法申请到足够的内存，就会抛出OOM异常

##### Native Method Stacks（本地方法栈）

与虚拟机栈非常相似，对应的是执行native 方法。

##### Java Heap（Java 堆）

* 线程共享的内存区域，存放对象实例。
* GC堆（采用分代收集算法）
* 堆可以处于物理上不连续的内存空间，只要逻辑上是连续的就可以。空间可以通过**-Xmx**和**-Xms**控制。
* 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OOM异常

##### Method Area (方法区)

* 线程共享的内存区域，存放jvm加载的类信息、常量、静态变量、即时编译器编译后的代码块等数据
* 当方法区无法满足内存分配需求时，会抛出OOM异常

> Runtime Constant Pool（运行时常量池）也是方法区的一部分，它是每个类私有的。每个class文件里的“常量池”在类被加载器加载之后，就映射存放在这个地方。
而String pool（字符串常量池）和运行时常量池不是一个概念**（容易混淆）**，String pool是全局共享的，**不在方法区内，在GC堆外（native memory）**。String pool的实现是一个StringTable类，它是一个Hash表。.在java7，8中使用 **-XX:StringTableSize** 参数设置字符串常量池的map大小。

###### Metaspace

> 在jdk8中 PermGen被移除，方法区移至 Metaspace ，可以通过**-XX:MaxMetaspaceSize**调整大小。（针对于Hotspot）

首先Metaspace（元空间）是哪一块区域呢？官方的解释是：
> In JDK 8, classes metadata is now stored in the native heap and this space is called Metaspace.

翻译过来就是：JDK 8 开始把类的元数据放到本地堆内存(native heap)中，这一块区域就叫 Metaspace。

再了解一下PermGen：

PermGen（永久代）是Hotspot虚拟机特有的概念，是方法区的一种实现，别的JVM都没有这个东西。而方法区（Method area）只是JVM规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，具体放在哪里，不同的实现可以放在不同的地方。

以及被移除的原因：

* 一部分是PermGen内存经常会溢出，导致OOM。
* 另外移除PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 并没有永久代。

##### Direct Memory (直接内存)

* 不属于虚拟机运行时数据区的一部分，但是频繁被调用，也可能导致出现OOM异常，在配置虚拟机参数时也需要注意。**（-XX:MaxDirectMemorySize）**

### Part 3

> 第三部分，**垃圾收集器与内存分配策略**

#### 可达性分析算法

目前可达性分析算法是判定对象是否存活的主流实现方式，从**GC Roots**的对象作为起点向下搜索，搜索中的路径称为引用链，当一个对象到**GC Roots**没有任何引用链相连时，则证明此对象是不可用。

那么是如何来判断**GC Roots**是否有引用链呢?

> 所谓**GC root**，就是一组必须活跃的引用。

这些引用可能包括：
* 所有Java活线程当前跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。
* 虚拟机栈中的引用的对象
* 本地方法栈中JNI的引用的对象
* （看情况）所有当前被加载的Java类
* （看情况）Java类的引用类型静态变量
* （看情况）Java类的运行时常量池里的引用类型常量（String或Class类型）
* （看情况）String常量池（StringTable）里的引用

**GC root**的根本思路就是：给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，其余对象就自然被判定为死亡。**GC root**的本质是通过找出所有活对象来把其余空间认定为“无用”，而不是找出所有死掉的对象并回收它们占用的空间。

而这些被判定为死亡的对象不是直接会被回收，而是至少经历两次标记过程。

* 第一次标记并进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。
* 第二次标记，如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为：F-Queue的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的Finalizer线程去执行。如果对象要在finalize（）中重新与引用链上的任何的一个对象建立关联将避免回收，反之则被回收。


用心读，细细写（待续...）