---
title: 深入理解Java虚拟机--读书笔记
date: 2018-01-29 21:57:24
type: "tags"
tags: [jvm]
---

> 最近认识到自己的薄弱点，需要狠狠补一下！

<!--more-->

花似雾中看，拨云见南山。
鲲鹏九万里，一览众山小。

### Part 1

> 第一部分，**走进java**，讲述了jvm的发展史，这里就不多做赘述了。贴上作者在infoq的文章~
[Java虚拟机家族考](http://www.infoq.com/cn/articles/jvm-family)


### Part 2 

> 第二部分，**自动内存管理机制**

#### 2.2 运行时数据区域

![Java虚拟机运行时数据区](http://oqipguzbl.bkt.clouddn.com/jvm-java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png)

##### Program Counter Register（程序计数器）

* 较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变计数器的值来选择下一条的指令，分支、循环、跳转、异常处理、线程恢复也依赖计数器。
* 每条线程独立拥有，且互不影响，独立存储（线程私有）
* 如果线程正在执行Java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是native方法，则这个计数器则为空。且是jvm中唯一没有规定OOM的区域。

这里对于计数器为何为空，转自[R大的回答](https://www.zhihu.com/question/40598119/answer/87381512)

这里的“pc寄存器”是在抽象的JVM层面上的概念——当执行Java方法时，这个抽象的“pc寄存器”存的是Java字节码的地址。实现上可能有两种形式，一种是相对该方法字节码开始处的偏移量，叫做bytecode index，简称bci；另一种是该Java字节码指令在内存里的地址，叫做bytecode pointer，简称bcp。

对native方法而言，它的方法体并不是由Java字节码构成的，自然无法应用上述的“Java字节码地址”的概念。所以JVM规范规定，如果当前执行的方法是native的，那么pc寄存器的值未定义——是什么值都可以。

上面是JVM规范所定义的抽象概念，那么实际实现呢？

Java线程总是需要以某种形式映射到OS线程上。映射模型可以是1:1（原生线程模型）、n:1（绿色线程/用户态线程模型）、m:n（混合模型）。

以HotSpot VM的实现为例，它目前在大多数平台上都使用1:1模型，也就是每个Java线程都直接映射到一个OS线程上执行。此时，native方法就由原生平台直接执行，并不需要理会抽象的JVM层面上的“pc寄存器”概念——原生的CPU上真正的PC寄存器是怎样就是怎样。就像一个用C或C++写的多线程程序，它在线程切换的时候是怎样的，Java的native方法也就是怎样的。


待续...