<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="google-site-verification" content="TOzgkVPl_tllvkMlt51RjNeTAmmf13oTLBbxTqhSO5E">
<meta name="baidu-site-verification" content="e8tBkAplgA">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="jvm,">








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.0">






<meta name="description" content="最近认识到自己的薄弱点，需要狠狠补一下！ 🥕">
<meta name="keywords" content="jvm">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Java虚拟机--读书笔记">
<meta property="og:url" content="https://7le.top/2018/01/29/深入理解Java虚拟机--读书笔记/index.html">
<meta property="og:site_name" content="Shine">
<meta property="og:description" content="最近认识到自己的薄弱点，需要狠狠补一下！ 🥕">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://github.com/7le/7le.github.io/raw/master/image/jvm/jvm-runtime.png">
<meta property="og:image" content="https://github.com/7le/7le.github.io/raw/master/image/jvm/Mark-Sweep.png">
<meta property="og:image" content="https://github.com/7le/7le.github.io/raw/master/image/jvm/Copying.png">
<meta property="og:image" content="https://github.com/7le/7le.github.io/raw/master/image/jvm/Mark-Compact.png">
<meta property="og:image" content="https://github.com/7le/7le.github.io/raw/master/image/jvm/serial.png">
<meta property="og:image" content="https://github.com/7le/7le.github.io/raw/master/image/jvm/parNew.png">
<meta property="og:image" content="https://github.com/7le/7le.github.io/raw/master/image/jvm/serial-old.png">
<meta property="og:image" content="https://github.com/7le/7le.github.io/raw/master/image/jvm/parallel-old.png">
<meta property="og:image" content="https://github.com/7le/7le.github.io/raw/master/image/jvm/cms.png">
<meta property="og:image" content="https://github.com/7le/7le.github.io/raw/master/image/jvm/垃圾收集相关的常用参数.jpg">
<meta property="og:image" content="https://github.com/7le/7le.github.io/raw/master/image/jvm/space-allocation-guarantee.png">
<meta property="og:updated_time" content="2019-06-19T06:29:39.413Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解Java虚拟机--读书笔记">
<meta name="twitter:description" content="最近认识到自己的薄弱点，需要狠狠补一下！ 🥕">
<meta name="twitter:image" content="https://github.com/7le/7le.github.io/raw/master/image/jvm/jvm-runtime.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://7le.top/2018/01/29/深入理解Java虚拟机--读书笔记/">





  <title> 深入理解Java虚拟机--读书笔记 | Shine </title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.2/gh-fork-ribbon.min.css">
  <script type="text/javascript">
    var host = "7le.top";
    if ((host == window.location.host) && (window.location.protocol != "https:"))
        window.location.protocol = "https";
  </script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?467d29ed3a4fecd3a1dca094a8c5a369";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Shine</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">耶和华是我的牧者，我必不致缺乏。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-tags " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://7le.top/2018/01/29/深入理解Java虚拟机--读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="7le">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/image/ly.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shine">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                深入理解Java虚拟机--读书笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-29T21:57:24+08:00">
                2018-01-29
              </time>
            

            

            
          </span>

          

          
            
                <span class="post-comments-count">
                  <span class="post-meta-divider">|</span>
                  <span class="post-meta-item-icon">
                    <i class="fa fa-comment-o"></i>
                  </span>
                  <a href="/2018/01/29/深入理解Java虚拟机--读书笔记/#comments" itemprop="discussionUrl">
                    <span class="post-comments-count gitment-comments-count" data-xid="/2018/01/29/深入理解Java虚拟机--读书笔记/" itemprop="commentsCount"></span>
                  </a>
                </span>
            
          

          
          
             <span id="/2018/01/29/深入理解Java虚拟机--读书笔记/" class="leancloud_visitors" data-flag-title="深入理解Java虚拟机--读书笔记">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>最近认识到自己的薄弱点，需要狠狠补一下！ 🥕</p>
</blockquote>
<a id="more"></a>
<p>花似雾中看，拨云见南山。<br>鲲鹏九万里，一览众山小。</p>
<h3 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h3><blockquote>
<p>第一部分，<strong>走进java</strong>，讲述了jvm的发展史，这里就不多做赘述了。贴上作者在infoq的文章~<br><a href="http://www.infoq.com/cn/articles/jvm-family" target="_blank" rel="noopener">Java虚拟机家族考</a></p>
</blockquote>
<h3 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h3><blockquote>
<p>第二部分，<strong>自动内存管理机制</strong></p>
</blockquote>
<h4 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h4><p><img src="https://github.com/7le/7le.github.io/raw/master/image/jvm/jvm-runtime.png" alt="Java虚拟机运行时数据区"></p>
<h5 id="Program-Counter-Register（程序计数器）"><a href="#Program-Counter-Register（程序计数器）" class="headerlink" title="Program Counter Register（程序计数器）"></a>Program Counter Register（程序计数器）</h5><ul>
<li>较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变计数器的值来选择下一条的指令，分支、循环、跳转、异常处理、线程恢复也依赖计数器。</li>
<li>每条线程独立拥有，且互不影响，独立存储（线程私有）</li>
<li>如果线程正在执行Java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是native方法，则这个计数器则为空。且是jvm中唯一没有规定OOM的区域。</li>
</ul>
<p>这里对于计数器为何为空，转自<a href="https://www.zhihu.com/question/40598119/answer/87381512" target="_blank" rel="noopener">R大的回答</a></p>
<p>这里的“pc寄存器”是在抽象的JVM层面上的概念——当执行Java方法时，这个抽象的“pc寄存器”存的是Java字节码的地址。实现上可能有两种形式，一种是相对该方法字节码开始处的偏移量，叫做bytecode index，简称bci；另一种是该Java字节码指令在内存里的地址，叫做bytecode pointer，简称bcp。</p>
<p>对native方法而言，它的方法体并不是由Java字节码构成的，自然无法应用上述的“Java字节码地址”的概念。所以JVM规范规定，如果当前执行的方法是native的，那么pc寄存器的值未定义——是什么值都可以。</p>
<p>上面是JVM规范所定义的抽象概念，那么实际实现呢？</p>
<p>Java线程总是需要以某种形式映射到OS线程上。映射模型可以是1:1（原生线程模型）、n:1（绿色线程/用户态线程模型）、m:n（混合模型）。</p>
<p>以HotSpot VM的实现为例，它目前在大多数平台上都使用1:1模型，也就是每个Java线程都直接映射到一个OS线程上执行。此时，native方法就由原生平台直接执行，并不需要理会抽象的JVM层面上的“pc寄存器”概念——原生的CPU上真正的PC寄存器是怎样就是怎样。就像一个用C或C++写的多线程程序，它在线程切换的时候是怎样的，Java的native方法也就是怎样的。</p>
<h5 id="Java-Virtual-Machine-Stacks（Java-虚拟机栈）"><a href="#Java-Virtual-Machine-Stacks（Java-虚拟机栈）" class="headerlink" title="Java Virtual Machine Stacks（Java 虚拟机栈）"></a>Java Virtual Machine Stacks（Java 虚拟机栈）</h5><ul>
<li>同样为线程私有</li>
<li>每个方法被执行的时候都会同时创建一个栈帧 （Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。</li>
<li>这里的局部变量表存放了各种基本类型（比如int、float等）<strong>其中64位的long和double类型占用2个局部变量空间（Slot）</strong>,其他占用为1个，<strong>对象引用</strong>（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向一条字节码指定的地址）</li>
<li>其中如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。以及在动态扩展内存的时候无法申请到足够的内存，就会抛出OOM异常</li>
</ul>
<h5 id="Native-Method-Stacks（本地方法栈）"><a href="#Native-Method-Stacks（本地方法栈）" class="headerlink" title="Native Method Stacks（本地方法栈）"></a>Native Method Stacks（本地方法栈）</h5><p>与虚拟机栈非常相似，对应的是执行native 方法。</p>
<h5 id="Java-Heap（Java-堆）"><a href="#Java-Heap（Java-堆）" class="headerlink" title="Java Heap（Java 堆）"></a>Java Heap（Java 堆）</h5><ul>
<li>线程共享的内存区域，存放对象实例以及数组。</li>
<li>GC堆（采用分代收集算法）</li>
<li>堆可以处于物理上不连续的内存空间，只要逻辑上是连续的就可以。空间可以通过<strong>-Xmx</strong>和<strong>-Xms</strong>控制。</li>
<li>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OOM异常</li>
</ul>
<h5 id="Method-Area-方法区"><a href="#Method-Area-方法区" class="headerlink" title="Method Area (方法区)"></a>Method Area (方法区)</h5><ul>
<li>线程共享的内存区域，存放jvm加载的类信息、常量、静态变量、即时编译器编译后的代码块等数据</li>
<li>当方法区无法满足内存分配需求时，会抛出OOM异常</li>
</ul>
<h5 id="Runtime-Constant-Pool（运行时常量池）"><a href="#Runtime-Constant-Pool（运行时常量池）" class="headerlink" title="Runtime Constant Pool（运行时常量池）"></a>Runtime Constant Pool（运行时常量池）</h5><p>Runtime Constant Pool 是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是Constant Pool Table（常量池），用于存放编译期生成的各种字面量和<a href="https://www.zhihu.com/question/30300585/answer/51335493" target="_blank" rel="noopener">符号引用</a>。</p>
<p>这里提一下String pool（字符串常量池），字符串常量池和运行时常量池不是一个概念<strong>（容易混淆）</strong>，String pool是全局共享的，在GC堆外（native memory）。String pool的实现是一个StringTable类，它是一个Hash表。.在java7，8中使用 <strong>-XX:StringTableSize</strong> 参数设置字符串常量池的map大小。</p>
<p>再补充一点，对HotSpot VM来说，不受GC管理的内存都是native memory；受GC管理的内存叫做GC heap或者managed heap。</p>
<h6 id="Metaspace"><a href="#Metaspace" class="headerlink" title="Metaspace"></a>Metaspace</h6><blockquote>
<p>在jdk8中 PermGen被移除，方法区移至 Metaspace ，可以通过<strong>-XX:MaxMetaspaceSize</strong>调整大小。（针对于Hotspot）</p>
</blockquote>
<p>首先Metaspace（元空间）是哪一块区域呢？官方的解释是：</p>
<blockquote>
<p>In JDK 8, classes metadata is now stored in the native heap and this space is called Metaspace.</p>
</blockquote>
<p>翻译过来就是：JDK 8 开始把类的元数据放到本地堆内存(native heap)中，这一块区域就叫 Metaspace。其中Oracle blog 提到的 native heap 应该是归属于 native memory（I guess）。</p>
<p>再了解一下PermGen：</p>
<p>PermGen（永久代）是Hotspot虚拟机特有的概念，是方法区的一种实现，别的JVM都没有这个东西。而方法区（Method area）只是JVM规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，具体放在哪里，不同的实现可以放在不同的地方。</p>
<p>以及被移除的原因：</p>
<ul>
<li>一部分是PermGen内存经常会溢出，导致OOM。</li>
<li>另外移除PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 并没有永久代。</li>
</ul>
<h5 id="Direct-Memory-直接内存"><a href="#Direct-Memory-直接内存" class="headerlink" title="Direct Memory (直接内存)"></a>Direct Memory (直接内存)</h5><ul>
<li>不属于虚拟机运行时数据区的一部分，但是频繁被调用，也可能导致出现OOM异常，在配置虚拟机参数时也需要注意。<strong>（-XX:MaxDirectMemorySize）</strong></li>
</ul>
<h3 id="Part-3"><a href="#Part-3" class="headerlink" title="Part 3"></a>Part 3</h3><blockquote>
<p>第三部分，<strong>垃圾收集器与内存分配策略</strong></p>
</blockquote>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>目前可达性分析算法是判定对象是否存活的主流实现方式，从<strong>GC Roots</strong>的对象作为起点向下搜索，搜索中的路径称为引用链，当一个对象到<strong>GC Roots</strong>没有任何引用链相连时，则证明此对象是不可用。</p>
<p>那么是如何来判断<strong>GC Roots</strong>是否有引用链呢?</p>
<blockquote>
<p>所谓<strong>GC Roots</strong>，就是一组必须活跃的引用。</p>
</blockquote>
<p>这些引用可能包括：</p>
<ul>
<li>所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。</li>
<li>虚拟机栈中的引用的对象</li>
<li>本地方法栈中JNI的引用的对象</li>
<li>（看情况）所有当前被加载的Java类</li>
<li>（看情况）Java类的引用类型静态变量</li>
<li>（看情况）Java类的运行时常量池里的引用类型常量（String或Class类型）</li>
<li>（看情况）String常量池（StringTable）里的引用</li>
</ul>
<p>另外<strong>GC Roots</strong>是否可以方便获取也至关重要，最初的虚拟机很多采用保守式GC，不记录这些信息，实现简单但是效率低。现在主流的虚拟机都采用准确式的GC，尽量早和方便地收集这些信息，加快整个标记的速度。</p>
<p>大致的实现思路是JVM采用了OopMap这个数据结构记录了<strong>GC Roots</strong>，GC的标记开始的时候，从OopMap就可以获得GC roots。OopMap记录了特定时刻栈上(内存)和寄存器(CPU)的哪些位置是引用，通过这些引用就可以找到堆中的对象，这些对象就是GC roots. 而不需要一个一个的去判断某个内存位置的值是不是引用。</p>
<p>有了OopMap就可以快速获得<strong>GC Roots</strong>，接着就可以开始标记了。标记的基本思路就是遍历一个有向图，节点是对象，边是引用，能被遍历到的（可到达的）对象就被判定为存活，其余对象就自然被判定为死亡。<strong>GC Roots</strong>的本质是通过找出所有活对象来把其余空间认定为“无用”，而不是找出所有死掉的对象并回收它们占用的空间。</p>
<p>而这些被判定为死亡的对象不是直接会被回收，而是至少经历两次标记过程。</p>
<ul>
<li>第一次标记并进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法。</li>
<li>第二次标记，如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为：F-Queue的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的Finalizer线程去执行。如果对象要在finalize（）中重新与引用链上的任何的一个对象建立关联将避免回收，反之则被回收。</li>
</ul>
<h4 id="Reference-（引用）"><a href="#Reference-（引用）" class="headerlink" title="Reference （引用）"></a>Reference （引用）</h4><ul>
<li>强引用: 用<strong>new</strong> 关键字修饰，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象</li>
<li>软引用: 用来描述一些还有用但是不是必需的对象。在将要oom的时候会将这些对象列进回首范围进行第二次回收。</li>
<li>弱引用: 用来描述非必需的对象，当垃圾收集器工作时，无论内存是否足够，都会回收掉被弱引用关联的对象。</li>
<li>虚引用: 它是最弱的一种引用关系，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li>
</ul>
<p>demo戳 <a href="https://github.com/7le/shine-learning/tree/master/java/src/main/java/com/java/references" target="_blank" rel="noopener">Reference demo</a></p>
<h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><h5 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h5><blockquote>
<p>“标记-清除”分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象</p>
</blockquote>
<p>它的主要缺点有两个：</p>
<ul>
<li>一个是效率问题，标记和清除过程的效率都不高；</li>
<li>另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ul>
<p><img src="https://github.com/7le/7le.github.io/raw/master/image/jvm/Mark-Sweep.png" alt="标记-清除算法"></p>
<h5 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h5><blockquote>
<p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。<br>当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
</blockquote>
<p>一般被用于新生代，新生代大部分的对象都是朝生夕死，所以内存分为一块较大的Eden空间和两块较小的Survivor空间，比例为8：1：1。<br>不过这个也要看实际情况来分配，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</p>
<p><img src="https://github.com/7le/7le.github.io/raw/master/image/jvm/Copying.png" alt="复制算法"></p>
<h5 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h5><blockquote>
<p>根据老年代的特点,有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p>
</blockquote>
<p><img src="https://github.com/7le/7le.github.io/raw/master/image/jvm/Mark-Compact.png" alt="标记-整理算法"></p>
<h5 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h5><blockquote>
<p>该算法是根据对象的存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代,在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。<br>而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p>
</blockquote>
<h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h5><blockquote>
<p>Serial收集器是最基本、历史最悠久的收集器，曾经（在JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。</p>
</blockquote>
<p>就像它的名字，这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程（Sun将这件事情称之为“Stop The World”），直到它收集结束。Serial收集器的运行过程如下图:</p>
<p><img src="https://github.com/7le/7le.github.io/raw/master/image/jvm/serial.png" alt="Serial"></p>
<h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h5><blockquote>
<p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、 -XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，实现上这两种收集器也共用了相当多的代码。</p>
</blockquote>
<p>ParNew收集器的运行过程如下图:</p>
<p><img src="https://github.com/7le/7le.github.io/raw/master/image/jvm/parNew.png" alt="ParNew"></p>
<h5 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h5><blockquote>
<p> Parallel Scavenge收集器也是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器</p>
</blockquote>
<p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 </p>
<h5 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h5><blockquote>
<p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。</p>
</blockquote>
<p>这个收集器的主要意义也是被Client模式下的虚拟机使用。如果在Server模式下，它主要还有两大用途：一个是在JDK 1.5及之前的版本中与Parallel Scavenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。Serial Old收集器的工作过程如下图：</p>
<p><img src="https://github.com/7le/7le.github.io/raw/master/image/jvm/serial-old.png" alt="Serial Old"></p>
<h5 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h5><blockquote>
<p> Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。</p>
</blockquote>
<p>Parallel Old的出现让”吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。Parallel Old收集器的工作过程如下图：</p>
<p><img src="https://github.com/7le/7le.github.io/raw/master/image/jvm/parallel-old.png" alt="Parallel Old"></p>
<h5 id="CMS-收集器-（Concurrent-Mark-Sweep）"><a href="#CMS-收集器-（Concurrent-Mark-Sweep）" class="headerlink" title="CMS 收集器 （Concurrent Mark Sweep）"></a>CMS 收集器 （Concurrent Mark Sweep）</h5><blockquote>
<p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器，基于<strong>标记-清除</strong>算法实现，作用于老年代。</p>
</blockquote>
<p>对于CMS 收集器，整个过程可以分为：</p>
<p><img src="https://github.com/7le/7le.github.io/raw/master/image/jvm/cms.png" alt="cms"></p>
<ul>
<li>初始标记（CMS initial mark）:STW，单线程，由于是从GCRoot寻找直达的对象，速度快。</li>
<li>并发标记（CMS concurrent mark）:与应用线程一起运行，是CMS最主要的工作阶段，通过直达对象，扫描全部的对象，进行标记。</li>
<li>重新标记（CMS remark）:STW，修正并发标记时由于应用程序还在并发运行产生的对象的修改，多线程，速度快，需要全局停顿。</li>
<li>并发清除（CMS concurrent sweep）:与应用程序一起运行。</li>
</ul>
<p>CMS 收集器主要优点是并发收集、低停顿。<br>其中初始标记和重新标记是需要<strong>Stop The World</strong>，初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。<br>由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。</p>
<p>而CMS也有明显的缺点:</p>
<ul>
<li>CMS收集器对CPU资源非常敏感。(并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程或者说CPU资源而导致应用程序变慢，总吞吐量会降低。)</li>
<li>CMS收集器无法处理浮动垃圾（Floating Garbage） （由于CMS并发清理阶段用户线程还在运行着，伴随程序的运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理掉它们，只好留待下一次GC时再将其清理掉，这一部分垃圾就称为“浮动垃圾”。）</li>
<li>产生大量空间碎片 （这是<strong>标记-清除</strong>算法所造成的）</li>
</ul>
<p>那CMS为何要采用<strong>标记-清除</strong>算法？</p>
<p>CMS主要关注低延迟，因而采用并发方式，清理垃圾时，应用程序还在运行，如果采用整理算法，则涉及到要移动应用程序的存活对象，此时不停顿，是很难处理的，一般需要停顿下，移动存活对象，再让应用程序继续运行，但这样停顿时间变长，延迟变大</p>
<p>而新的G1（Garbage-First）把整个GC堆划分为许多小区域（region），通过每次GC只选择收集很少量region来控制移动对象带来的暂停时间。这样既能实现低延迟也不会受碎片化的影响。 </p>
<h5 id="G1-收集器-（Garbage-First）"><a href="#G1-收集器-（Garbage-First）" class="headerlink" title="G1 收集器 （Garbage-First）"></a>G1 收集器 （Garbage-First）</h5><blockquote>
<p>G1 收集器可以支持并行与并发，单个收集器就可以管理整个GC堆（分代算法），与CMS不同的是基于<strong>标记-整理</strong>算法，以及支持可预测的停顿。</p>
</blockquote>
<p>对于G1 收集器 ，整个过程大致可以分为：</p>
<ul>
<li>初始标记（Initial Marking）</li>
<li>并发标记（Concurrent Marking）</li>
<li>最终标记（Final Marking）</li>
<li>筛选回收（Live Data Counting and Evacuation）。</li>
</ul>
<p>与CMS收集器非常相近，初始标记阶段仅仅是标记一下GC Roots能直接关联到的对象，并修改TAMS的值，让下一阶段用户程序并发运行时，能正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。并发阶段是从GC Roots开始对堆中对象进行可达性分析，耗时较长，可与用户线程并发。<br>而最终标记阶段是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录。虚拟机将这段时间对象变化记录在线程Remenbered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这一阶段需要停顿线程，但是可并行执行。最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。</p>
<p>G1收集器是垃圾收集器理论进一步发展的产物，它具备以下的特点：</p>
<ul>
<li>并行与并发（G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU或者CPU核心来缩短STP停顿时间。）</li>
<li>分代收集（虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。）</li>
<li>空间整合（G1收集器是基于<strong>标记-整理</strong>算法实现的收集器，也就是说它不会产生空间碎片，这对于长时间运行的应用系统来说非常重要。）</li>
<li>可预测的停顿 （它可以非常精确地控制停顿，既能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。） </li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>总的来说，除了G1目前都可分为新生代和老年代算法。这些算法有两个性能侧重点：1. 回收停顿时间；2. 吞吐量。<br>偏向前者的有 CMS 和 G1，CMS 属于老年代收集器，常与 CMS 搭配使用的是 ParNew 收集器。<br>偏重吞吐量的算法是 Parallel Scavenge（复制算法），这是个新生代收集器，常与之搭配的老生代算法是 Parallel Old（多线程、标记-整理算法）。</p>
<h4 id="理解gc日志"><a href="#理解gc日志" class="headerlink" title="理解gc日志"></a>理解gc日志</h4><p>阅读GC日志是处理jvm的基础技能，可以配置上<code>-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:/logs/gc.log</code>，jvm就能为我们将日志输出到指定的路径下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4.533: [GC (Allocation Failure) 4.533: [ParNew: 1041729K-&gt;77803K(1061696K), 0.0825433 secs] 1041729K-&gt;87450K(3027776K), 0.0826023 secs] [Times: user=0.16 sys=0.03, real=0.08 secs]</span><br><span class="line">99.631: [Full GC (System.gc()) 99.631: [CMS: 9646K-&gt;53928K(1966080K), 0.2198137 secs] 883651K-&gt;53928K(3027776K), [Metaspace: 45355K-&gt;45355K(1089536K)], 0.2201145 secs] [Times: user=0.24 sys=0.00, real=0.22 secs]</span><br></pre></td></tr></table></figure>
<p>最前的数字，<strong>4.533</strong>和<strong>99.631</strong>代表GC发生的时间，是从jvm启动以来经过的秒数。</p>
<p>后面的<strong>GC</strong>和<strong>Full GC</strong>是用来区分收集区域的。<strong>GC</strong>说明只收集GC堆的部分区域。通常就是minor GC，只收集young gen。<strong>Full GC</strong>说明收集了整个GC堆的所有区域，包括young、old、perm（如果有perm）。后面中的<strong>Allocation Failure</strong>，<strong>System.gc()</strong>是触发的原因。</p>
<p>然后<strong>ParNew</strong>和<strong>CMS</strong>是分代的垃圾收集器，上面有提及过。<strong>1041729K-&gt;77803K(1061696K)</strong>表示GC前该区域已使用容量-&gt;GC后该区域已使用容量</p>
<p>而在方括号外面的<strong>1041729K-&gt;87450K(3027776K)</strong> 表示GC前Java堆已使用容量-&gt;GC后java堆已使用的容量（Java堆总容量）</p>
<p>从以上的信息我们可以计算出在垃圾收集期间, JVM中的内存使用情况。在垃圾收集之前, 堆内存总的使用了<strong>0.99G(1041729K)</strong>，其中,年轻代使用了<strong>0.99G(1041729K)</strong>，老年代还没开始使用，说明是刚刚开始的gc日志。而从<strong>(1041729K-77803K)-(1041729K-87450K)=9647(9.42M)</strong>可以知道有<strong>9.42M</strong>年轻代对象被提升到老年代中。</p>
<p>再往后<strong>[Times: user=0.16 sys=0.03, real=0.08 secs]</strong>与Linux命令所输出的时间含义一致，分别代表用户态消耗的CPU时间、内核态消耗的CPU时间和操作从开始到结束锁经过的墙钟时间（Wall Clock Time）。墙钟时间与 CPU时间的区别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘I/O、等待线程紫塞。而CPU时间不包括这些，但是多CPU或者多核，多线程操作会叠加这些CPU时间。</p>
<h4 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h4><p><img src="https://github.com/7le/7le.github.io/raw/master/image/jvm/垃圾收集相关的常用参数.jpg" alt="垃圾收集相关的常用参数"></p>
<h4 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h4><h5 id="对象优先分配Eden区"><a href="#对象优先分配Eden区" class="headerlink" title="对象优先分配Eden区"></a>对象优先分配Eden区</h5><blockquote>
<p>大多数情况下，对象在新生代Eden区中分配。当Eden空间不足，则会发生一次<code>Minor GC</code>。</p>
</blockquote>
<h5 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h5><blockquote>
<p>大对象是指需要大量连续内存空间的java对象（典型的如长字符串和数组），当新生代不足以存放大对象，就会跳过新生代直接老年代。</p>
</blockquote>
<h5 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h5><blockquote>
<p>Jvm给每个对象定义了一个对象年龄(Age)计数器。如果对象在Eden出生并经过第一次<code>Minor GC</code>后仍然存活，并且能被<code>Survivor</code>容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每熬过一次<code>Minor GC</code>，年龄就增加1岁。当它的年龄增加到一定程度（默认是15岁），将会被晋升到老年代。可以通过<code>-XX:MaxTenuringThreshold</code>参数设置晋升老年代的阈值</p>
</blockquote>
<h5 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h5><blockquote>
<p>为了能更好地适应不同程序的内存情况，Jvm并不总是要求对象的年龄必须达到<code>MaxTenuringThreshold</code>才能晋升老年代。如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p>
</blockquote>
<h5 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h5><p><img src="https://github.com/7le/7le.github.io/raw/master/image/jvm/space-allocation-guarantee.png" alt="空间分配担保"></p>
<p>图中提到了是否允许担保失败，当新生代使用复制收集算法，但是为了内存利用率，只使用其中一个<code>Survivor</code>空间来作为轮换备份，因此当出现大量对象在<code>Minor GC</code>后依然存活（最极端就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把<code>Survivor</code>无法容纳的对象直接进入老年代。但是多少会晋升到老年代在实际内存回收前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均值作为经验值，与老年代剩余空间比较，决定是否进行<code>Full GC</code>来让老年代腾出更多空间。</p>
<p>取平均值任然是一种动态概率的手段，依然会出现担保失败，那时绕的圈子是最大的，但大部分情况下还是会将<code>HandlePromotionFailure</code>打开，避免<code>Full GC</code>过于频繁。</p>
<hr>
<p><a href="https://github.com/7le" target="_blank" rel="noopener">Github</a> 不要吝啬你的star ^.^<br><a href="https://7le.top">更多精彩 戳我</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/jvm/" rel="tag"># jvm</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/04/Tidb的日常/" rel="next" title="Tidb的日常">
                <i class="fa fa-chevron-left"></i> Tidb的日常
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/18/pgsql笔记/" rel="prev" title="pgsql笔记">
                pgsql笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8yOTIxNS81Nzgy"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/image/ly.jpg" alt="7le">
          <p class="site-author-name" itemprop="name">7le</p>
           
              <p class="site-description motion-element" itemprop="description">我只有一件事，就是忘记背后，努力面前的</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">26</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/7le" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://palmer.arkstack.cn" title="palmerye" target="_blank">palmerye</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Part-1"><span class="nav-number">1.</span> <span class="nav-text">Part 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Part-2"><span class="nav-number">2.</span> <span class="nav-text">Part 2</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#运行时数据区域"><span class="nav-number">2.1.</span> <span class="nav-text">运行时数据区域</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Program-Counter-Register（程序计数器）"><span class="nav-number">2.1.1.</span> <span class="nav-text">Program Counter Register（程序计数器）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Java-Virtual-Machine-Stacks（Java-虚拟机栈）"><span class="nav-number">2.1.2.</span> <span class="nav-text">Java Virtual Machine Stacks（Java 虚拟机栈）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Native-Method-Stacks（本地方法栈）"><span class="nav-number">2.1.3.</span> <span class="nav-text">Native Method Stacks（本地方法栈）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Java-Heap（Java-堆）"><span class="nav-number">2.1.4.</span> <span class="nav-text">Java Heap（Java 堆）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Method-Area-方法区"><span class="nav-number">2.1.5.</span> <span class="nav-text">Method Area (方法区)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Runtime-Constant-Pool（运行时常量池）"><span class="nav-number">2.1.6.</span> <span class="nav-text">Runtime Constant Pool（运行时常量池）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Metaspace"><span class="nav-number">2.1.6.1.</span> <span class="nav-text">Metaspace</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Direct-Memory-直接内存"><span class="nav-number">2.1.7.</span> <span class="nav-text">Direct Memory (直接内存)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Part-3"><span class="nav-number">3.</span> <span class="nav-text">Part 3</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可达性分析算法"><span class="nav-number">3.1.</span> <span class="nav-text">可达性分析算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reference-（引用）"><span class="nav-number">3.2.</span> <span class="nav-text">Reference （引用）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#垃圾收集算法"><span class="nav-number">3.3.</span> <span class="nav-text">垃圾收集算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#标记-清除算法（Mark-Sweep）"><span class="nav-number">3.3.1.</span> <span class="nav-text">标记-清除算法（Mark-Sweep）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#复制算法（Copying）"><span class="nav-number">3.3.2.</span> <span class="nav-text">复制算法（Copying）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#标记-整理算法（Mark-Compact）"><span class="nav-number">3.3.3.</span> <span class="nav-text">标记-整理算法（Mark-Compact）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#分代收集算法"><span class="nav-number">3.3.4.</span> <span class="nav-text">分代收集算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#垃圾收集器"><span class="nav-number">3.4.</span> <span class="nav-text">垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Serial-收集器"><span class="nav-number">3.4.1.</span> <span class="nav-text">Serial 收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ParNew-收集器"><span class="nav-number">3.4.2.</span> <span class="nav-text">ParNew 收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Parallel-Scavenge-收集器"><span class="nav-number">3.4.3.</span> <span class="nav-text">Parallel Scavenge 收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Serial-Old-收集器"><span class="nav-number">3.4.4.</span> <span class="nav-text">Serial Old 收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Parallel-Old-收集器"><span class="nav-number">3.4.5.</span> <span class="nav-text">Parallel Old 收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CMS-收集器-（Concurrent-Mark-Sweep）"><span class="nav-number">3.4.6.</span> <span class="nav-text">CMS 收集器 （Concurrent Mark Sweep）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#G1-收集器-（Garbage-First）"><span class="nav-number">3.4.7.</span> <span class="nav-text">G1 收集器 （Garbage-First）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#总结"><span class="nav-number">3.4.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#理解gc日志"><span class="nav-number">3.5.</span> <span class="nav-text">理解gc日志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#垃圾收集器参数总结"><span class="nav-number">3.6.</span> <span class="nav-text">垃圾收集器参数总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存分配与回收策略"><span class="nav-number">3.7.</span> <span class="nav-text">内存分配与回收策略</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对象优先分配Eden区"><span class="nav-number">3.7.1.</span> <span class="nav-text">对象优先分配Eden区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#大对象直接进入老年代"><span class="nav-number">3.7.2.</span> <span class="nav-text">大对象直接进入老年代</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#长期存活的对象将进入老年代"><span class="nav-number">3.7.3.</span> <span class="nav-text">长期存活的对象将进入老年代</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#动态对象年龄判定"><span class="nav-number">3.7.4.</span> <span class="nav-text">动态对象年龄判定</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#空间分配担保"><span class="nav-number">3.7.5.</span> <span class="nav-text">空间分配担保</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
<div class="copyright">
  
  &copy;  2017 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <a class="theme-link" href="https://github.com/7le" target="view_window" style="cursor: pointer" rel="external nofollow">
    7le
  </a>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io" rel="external nofollow">Hexo</a>
</div>

<span id="busuanzi_container_site_pv">
  PV <span id="busuanzi_value_site_pv"></span>
</span>
<span id="busuanzi_container_site_uv">
  &nbsp&nbsp | &nbsp&nbsp UV <span id="busuanzi_value_site_uv"></span>
</span>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  








  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: window.location.pathname,
            owner: '7le',
            repo: '7le.github.io',
            
            lang: "" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: 'c53d2248f8cd0c5003b8c92b5a9e27299cf96e99',
            
                client_id: '36f5a95fff3d8ff6cadd'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    



  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("tNiTejf4rdhMUUhMzh7SEzUI-gzGzoHsz", "qhTCrCTlLqVQcfs3eAwwuqqB");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  <a class="github-fork-ribbon left-bottom fixed" href="https://github.com/7le" data-ribbon="Follow me on GitHub" title="Follow me on GitHub">Follow me on GitHub</a>
</body>
</html>



